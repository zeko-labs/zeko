schema {
  query: query
  mutation: mutation
  subscription: subscription
}

"""
"""
type query {
  """
  Network sync status
  """
  syncStatus: SyncStatus!

  """
  Get running daemon status
  """
  daemonStatus: DaemonStatus!

  """
  The version of the node (git commit hash)
  """
  version: String

  """
  Wallets for which the daemon knows the private key
  """
  ownedWallets: [Account!]! @deprecated(reason: "use trackedAccounts instead")

  """
  Find any wallet via a public key
  """
  wallet(
    """
    Public key of account being retrieved
    """
    publicKey: PublicKey!
  ): Account @deprecated(reason: "use account instead")

  """
  Find any account via a public key and token
  """
  account(
    """
    Token of account being retrieved (defaults to MINA)
    """
    token: TokenId

    """
    Public key of account being retrieved
    """
    publicKey: PublicKey!
  ): Account

  """
  Find all accounts for a public key
  """
  accounts(
    """
    Public key to find accounts for
    """
    publicKey: PublicKey!
  ): [Account!]!

  """
  Find the account that owns a given token
  """
  tokenOwner(
    """
    Token ID to find the owning account for
    """
    tokenId: TokenId!
  ): Account

  """
  Find all accounts for a token ID
  """
  tokenAccounts(
    """
    Token ID to find accounts for
    """
    tokenId: TokenId!
  ): [Account!]!

  """
  Retrieve a list of blocks from transition frontier's root to the current best
  tip. Returns an error if the system is bootstrapping.
  """
  bestChain(
    """
    The maximum number of blocks to return. If there are more blocks in the
    transition frontier from root to tip, the n blocks closest to the best tip
    will be returned
    """
    maxLength: Int
  ): [Block!]

  """
  Retrieve a block with the given state hash or height, if contained in the transition frontier.
  """
  block(
    """
    The height of the desired block in the best chain
    """
    height: Int

    """
    The state hash of the desired block
    """
    stateHash: String
  ): Block!

  """
  Get the genesis block
  """
  genesisBlock: Block!

  """
  List of peers that the daemon first used to connect to the network
  """
  initialPeers: [String!]!

  """
  List of peers that the daemon is currently connected to
  """
  getPeers: [Peer!]!

  """
  Retrieve all the scheduled user commands for a specified sender that the
  current daemon sees in its transaction pool. All scheduled commands are
  queried if no sender is specified
  """
  pooledUserCommands(
    """
    Ids of User commands
    """
    ids: [ID!]

    """
    Hashes of the commands to find in the pool
    """
    hashes: [String!]

    """
    Public key of sender of pooled user commands
    """
    publicKey: PublicKey
  ): [UserCommand!]!

  """
  Retrieve all the scheduled zkApp commands for a specified sender that the
  current daemon sees in its transaction pool. All scheduled commands are
  queried if no sender is specified
  """
  pooledZkappCommands(
    """
    Ids of zkApp commands
    """
    ids: [ID!]

    """
    Hashes of the zkApp commands to find in the pool
    """
    hashes: [String!]

    """
    Public key of sender of pooled zkApp commands
    """
    publicKey: PublicKey
  ): [ZkappCommandResult!]!

  """
  Get the status of a transaction
  """
  transactionStatus(
    """
    Id of a zkApp transaction
    """
    zkappTransaction: ID

    """
    Id of a Payment
    """
    payment: ID
  ): TransactionStatus!

  """
  Trust status for an IPv4 or IPv6 address
  """
  trustStatus(ipAddress: String!): [TrustStatusPayload!]

  """
  IP address and trust status for all peers
  """
  trustStatusAll: [TrustStatusPayload!]!

  """
  List of completed snark works that have the lowest fee so far
  """
  snarkPool: [CompletedWork!]!

  """
  List of snark works that are yet to be done
  """
  pendingSnarkWork: [PendingSnarkWork!]!

  """
  The constants used to determine the configuration of the genesis block and all of its transitive dependencies
  """
  genesisConstants: GenesisConstants!

  """
  The time offset in seconds used to convert real times into blockchain times
  """
  timeOffset: Int!

  """
  Validate the format and signature of a payment
  """
  validatePayment(
    """
    If a signature is provided, this transaction is considered signed and will
    be broadcasted to the network without requiring a private key
    """
    signature: SignatureInput

    """
    """
    input: SendPaymentInput!
  ): Boolean!

  """
  Evaluate a vrf for the given public key. This includes a witness which may be
  verified without access to the private key for this vrf evaluation.
  """
  evaluateVrf(
    vrfThreshold: VrfThresholdInput
    publicKey: PublicKey!
    message: VrfMessageInput!
  ): VrfEvaluation!

  """
  Check a vrf evaluation commitment. This can be used to check vrf evaluations
  without needing to reveal the private key, in the format returned by evaluateVrf
  """
  checkVrf(input: VrfEvaluationInput!): VrfEvaluation!

  """
  The pickles verification key for the protocol state proof
  """
  blockchainVerificationKey: JSON!
}

"""
Sync status of daemon
"""
enum SyncStatus {
  """
  """
  CONNECTING

  """
  """
  LISTENING

  """
  """
  OFFLINE

  """
  """
  BOOTSTRAP

  """
  """
  SYNCED

  """
  """
  CATCHUP
}

"""
"""
type DaemonStatus {
  """
  """
  numAccounts: Int

  """
  """
  blockchainLength: Int

  """
  """
  highestBlockLengthReceived: Int!

  """
  """
  highestUnvalidatedBlockLengthReceived: Int!

  """
  """
  uptimeSecs: Int!

  """
  """
  ledgerMerkleRoot: String

  """
  """
  stateHash: String

  """
  """
  chainId: String!

  """
  """
  commitId: String!

  """
  """
  confDir: String!

  """
  """
  peers: [Peer!]!

  """
  """
  userCommandsSent: Int!

  """
  """
  snarkWorker: String

  """
  """
  snarkWorkFee: Int!

  """
  """
  syncStatus: SyncStatus!

  """
  """
  catchupStatus: [String!]

  """
  """
  blockProductionKeys: [String!]!

  """
  """
  coinbaseReceiver: String

  """
  """
  histograms: Histograms

  """
  """
  consensusTimeBestTip: ConsensusTime

  """
  """
  globalSlotSinceGenesisBestTip: Int

  """
  """
  nextBlockProduction: BlockProducerTimings

  """
  """
  consensusTimeNow: ConsensusTime!

  """
  """
  consensusMechanism: String!

  """
  """
  consensusConfiguration: ConsensusConfiguration!

  """
  """
  addrsAndPorts: AddrsAndPorts!

  """
  """
  metrics: Metrics!
}

"""
"""
type Peer {
  """
  """
  host: String!

  """
  """
  libp2pPort: Int!

  """
  """
  peerId: String!
}

"""
"""
type Histograms {
  """
  """
  rpcTimings: RpcTimings!

  """
  """
  externalTransitionLatency: Histogram

  """
  """
  acceptedTransitionLocalLatency: Histogram

  """
  """
  acceptedTransitionRemoteLatency: Histogram

  """
  """
  snarkWorkerTransitionTime: Histogram

  """
  """
  snarkWorkerMergeTime: Histogram
}

"""
"""
type RpcTimings {
  """
  """
  getStagedLedgerAux: RpcPair!

  """
  """
  answerSyncLedgerQuery: RpcPair!

  """
  """
  getAncestry: RpcPair!

  """
  """
  getTransitionChainProof: RpcPair!

  """
  """
  getTransitionChain: RpcPair!
}

"""
"""
type RpcPair {
  """
  """
  dispatch: Histogram

  """
  """
  impl: Histogram
}

"""
"""
type Histogram {
  """
  """
  values: [Int!]!

  """
  """
  intervals: [Interval!]!

  """
  """
  underflow: Int!

  """
  """
  overflow: Int!
}

"""
"""
type Interval {
  """
  """
  start: Span!

  """
  """
  stop: Span!
}

"""
span
"""
scalar Span

"""
"""
type ConsensusTime {
  """
  """
  epoch: UInt32!

  """
  """
  slot: UInt32!

  """
  """
  globalSlot: Globalslot!

  """
  """
  startTime: BlockTime!

  """
  """
  endTime: BlockTime!
}

"""
String representing a uint32 number in base 10
"""
scalar UInt32

"""
globalslot
"""
scalar Globalslot

scalar BlockTime

"""
"""
type BlockProducerTimings {
  """
  Next block production time
  """
  times: [ConsensusTime!]!

  """
  Next block production global-slot-since-genesis
  """
  globalSlotSinceGenesis: [Globalslot!]!

  """
  Consensus time of the block that was used to determine the next block production time
  """
  generatedFromConsensusAt: ConsensusTimeGlobalSlot!
}

"""
Consensus time and the corresponding global slot since genesis
"""
type ConsensusTimeGlobalSlot {
  """
  Time in terms of slot number in an epoch, start and end time of the slot since UTC epoch
  """
  consensusTime: ConsensusTime!

  """
  """
  globalSlotSinceGenesis: Globalslot!
}

"""
"""
type ConsensusConfiguration {
  """
  """
  delta: Int!

  """
  """
  k: Int!

  """
  """
  slotsPerEpoch: Int!

  """
  """
  slotDuration: Int!

  """
  """
  epochDuration: Int!

  """
  """
  genesisStateTimestamp: Time!

  """
  """
  acceptableNetworkDelay: Int!
}

scalar Time

"""
"""
type AddrsAndPorts {
  """
  """
  externalIp: String!

  """
  """
  bindIp: String!

  """
  """
  peer: Peer

  """
  """
  libp2pPort: Int!

  """
  """
  clientPort: Int!
}

"""
"""
type Metrics {
  """
  """
  blockProductionDelay: [Int!]!

  """
  """
  transactionPoolDiffReceived: Int!

  """
  """
  transactionPoolDiffBroadcasted: Int!

  """
  """
  transactionsAddedToPool: Int!

  """
  """
  transactionPoolSize: Int!
}

"""
An account record according to the daemon
"""
type Account {
  """
  The public identity of the account
  """
  publicKey: PublicKey!

  """
  The token associated with this account
  """
  tokenId: TokenId!

  """
  The token associated with this account
  """
  token: TokenId! @deprecated(reason: "Use tokenId")

  """
  The timing associated with this account
  """
  timing: AccountTiming!

  """
  The amount of MINA owned by the account
  """
  balance: AnnotatedBalance!

  """
  A natural number that increases with each transaction (stringified uint32)
  """
  nonce: AccountNonce

  """
  Like the `nonce` field, except it includes the scheduled transactions
  (transactions not yet included in a block) (stringified uint32)
  """
  inferredNonce: AccountNonce

  """
  The account that you delegated on the staking ledger of the current block's epoch
  """
  epochDelegateAccount: Account

  """
  Top hash of the receipt chain Merkle-list
  """
  receiptChainHash: ChainHash

  """
  The public key to which you are delegating - if you are not delegating to anybody, this would return your public key
  """
  delegate: PublicKey @deprecated(reason: "use delegateAccount instead")

  """
  The account to which you are delegating - if you are not delegating to anybody, this would return your public key
  """
  delegateAccount: Account

  """
  The list of accounts which are delegating to you (note that the info is
  recorded in the last epoch so it might not be up to date with the current
  account status)
  """
  delegators: [Account!]

  """
  The list of accounts which are delegating to you in the last epoch (note that
  the info is recorded in the one before last epoch epoch so it might not be up
  to date with the current account status)
  """
  lastEpochDelegators: [Account!]

  """
  The previous epoch lock hash of the chain which you are voting for
  """
  votingFor: ChainHash

  """
  True if you are actively staking with this account on the current daemon -
  this may not yet have been updated if the staking key was changed recently
  """
  stakingActive: Boolean!

  """
  Path of the private key file for this account
  """
  privateKeyPath: String!

  """
  True if locked, false if unlocked, null if the account isn't tracked by the queried daemon
  """
  locked: Boolean

  """
  The index of this account in the ledger, or null if this account does not yet have a known position in the best tip ledger
  """
  index: Int

  """
  The URI associated with this account, usually pointing to the zkApp source code
  """
  zkappUri: String

  """
  The 8 field elements comprising the zkApp state associated with this account encoded as bignum strings
  """
  zkappState: [FieldElem!]

  """
  Boolean indicating whether all 8 fields on zkAppState were last set by a proof-authorized account update
  """
  provedState: Boolean

  """
  Permissions for updating certain fields of this account
  """
  permissions: AccountPermissions

  """
  The symbol for the token owned by this account, if there is one
  """
  tokenSymbol: String

  """
  Verification key associated with this account
  """
  verificationKey: AccountVerificationKeyWithHash

  """
  Action state associated with this account
  """
  actionState: [Action!]

  """
  The base58Check-encoded hash of this account to bootstrap the merklePath
  """
  leafHash: FieldElem

  """
  Merkle path is a list of path elements that are either the left or right hashes up to the root
  """
  merklePath: [MerklePathElement!]
}

"""
Base58Check-encoded public key string
"""
scalar PublicKey

"""
String representation of a token's UInt64 identifier
"""
scalar TokenId

"""
"""
type AccountTiming {
  """
  The initial minimum balance for a time-locked account
  """
  initialMinimumBalance: Balance

  """
  The cliff time for a time-locked account
  """
  cliffTime: Globalslot

  """
  The cliff amount for a time-locked account
  """
  cliffAmount: Amount

  """
  The vesting period for a time-locked account
  """
  vestingPeriod: Globalslot

  """
  The vesting increment for a time-locked account
  """
  vestingIncrement: Amount
}

"""
balance
"""
scalar Balance

"""
amount
"""
scalar Amount

"""
A total balance annotated with the amount that is currently unknown with the
invariant unknown <= total, as well as the currently liquid and locked balances.
"""
type AnnotatedBalance {
  """
  The amount of MINA owned by the account
  """
  total: Balance!

  """
  The amount of MINA owned by the account whose origin is currently unknown
  """
  unknown: Balance!

  """
  The amount of MINA owned by the account which is currently available. Can be null if bootstrapping.
  """
  liquid: Balance

  """
  The amount of MINA owned by the account which is currently locked. Can be null if bootstrapping.
  """
  locked: Balance

  """
  Block height at which balance was measured
  """
  blockHeight: Length!

  """
  Hash of block at which balance was measured. Can be null if bootstrapping.
  Guaranteed to be non-null for direct account lookup queries when not
  bootstrapping. Can also be null when accessed as nested properties (eg. via delegators).
  """
  stateHash: StateHash
}

"""
length
"""
scalar Length

"""
Base58Check-encoded state hash
"""
scalar StateHash

"""
account nonce
"""
scalar AccountNonce

"""
Base58Check-encoded chain hash
"""
scalar ChainHash

"""
field element
"""
scalar FieldElem

"""
"""
type AccountPermissions {
  """
  Authorization required to edit zkApp state
  """
  editState: AccountAuthRequired!

  """
  Authorization required to send tokens
  """
  send: AccountAuthRequired!

  """
  Authorization required to receive tokens
  """
  receive: AccountAuthRequired!

  """
  Authorization required to access the account
  """
  access: AccountAuthRequired!

  """
  Authorization required to set the delegate
  """
  setDelegate: AccountAuthRequired!

  """
  Authorization required to change permissions
  """
  setPermissions: AccountAuthRequired!

  """
  Authorization required to set the verification key of the zkApp associated with the account
  """
  setVerificationKey: AccountAuthRequired!

  """
  Authorization required to change the URI of the zkApp associated with the account
  """
  setZkappUri: AccountAuthRequired!

  """
  Authorization required to edit the action state
  """
  editActionState: AccountAuthRequired!

  """
  Authorization required to set the token symbol
  """
  setTokenSymbol: AccountAuthRequired!

  """
  Authorization required to increment the nonce
  """
  incrementNonce: AccountAuthRequired!

  """
  Authorization required to set the state hash the account is voting for
  """
  setVotingFor: AccountAuthRequired!

  """
  Authorization required to set the timing of the account
  """
  setTiming: AccountAuthRequired!
}

"""
Kind of authorization required
"""
enum AccountAuthRequired {
  """
  """
  None

  """
  """
  Either

  """
  """
  Proof

  """
  """
  Signature

  """
  """
  Impossible
}

"""
Verification key with hash
"""
type AccountVerificationKeyWithHash {
  """
  verification key in Base64 format
  """
  verificationKey: VerificationKey!

  """
  Hash of verification key
  """
  hash: VerificationKeyHash!
}

"""
verification key in Base64 format
"""
scalar VerificationKey

"""
Hash of verification key
"""
scalar VerificationKeyHash

"""
action
"""
scalar Action

"""
"""
type MerklePathElement {
  """
  """
  left: FieldElem

  """
  """
  right: FieldElem
}

"""
"""
type Block {
  """
  Public key of account that produced this block
  """
  creator: PublicKey! @deprecated(reason: "use creatorAccount field instead")

  """
  Account that produced this block
  """
  creatorAccount: Account!

  """
  Account that won the slot (Delegator/Staker)
  """
  winnerAccount: Account!

  """
  Base58Check-encoded hash of the state after this block
  """
  stateHash: StateHash!

  """
  Experimental: Bigint field-element representation of stateHash
  """
  stateHashField: StateHashAsDecimal!

  """
  """
  protocolState: ProtocolState!

  """
  Snark proof of blockchain state
  """
  protocolStateProof: protocolStateProof!

  """
  """
  transactions: Transactions!

  """
  Count of user command transactions in the block
  """
  commandTransactionCount: Int!

  """
  """
  snarkJobs: [CompletedWork!]!
}

"""
Experimental: Bigint field-element representation of stateHash
"""
scalar StateHashAsDecimal

"""
"""
type ProtocolState {
  """
  Base58Check-encoded hash of the previous state
  """
  previousStateHash: StateHash!

  """
  State which is agnostic of a particular consensus algorithm
  """
  blockchainState: BlockchainState!

  """
  State specific to the minaboros Proof of Stake consensus algorithm
  """
  consensusState: ConsensusState!
}

"""
"""
type BlockchainState {
  """
  date (stringified Unix time - number of milliseconds since January 1, 1970)
  """
  date: BlockTime!

  """
  utcDate (stringified Unix time - number of milliseconds since January 1,
  1970). Time offsets are adjusted to reflect true wall-clock time instead of genesis time.
  """
  utcDate: BlockTime!

  """
  Base58Check-encoded hash of the snarked ledger
  """
  snarkedLedgerHash: LedgerHash!

  """
  Base58Check-encoded hash of the staged ledger hash's main ledger hash
  """
  stagedLedgerHash: LedgerHash!

  """
  Base58Check-encoded hash of the staged ledger hash's aux_hash
  """
  stagedLedgerAuxHash: StagedLedgerAuxHash!

  """
  Base58Check-encoded staged ledger hash's pending_coinbase_aux
  """
  stagedLedgerPendingCoinbaseAux: PendingCoinbaseAuxHash!

  """
  Base58Check-encoded hash of the staged ledger hash's pending_coinbase_hash
  """
  stagedLedgerPendingCoinbaseHash: PendingCoinbaseHash!

  """
  Block finished a staged ledger, and a proof was emitted from it and included
  into this block's proof. If there is no transition frontier available or no
  block found, this will return null.
  """
  stagedLedgerProofEmitted: Boolean

  """
  A reference to how the block header refers to the body of the block as a hex-encoded string
  """
  bodyReference: BodyReference!
}

"""
Base58Check-encoded ledger hash
"""
scalar LedgerHash

"""
Base58Check-encoded hash of the staged ledger hash's aux_hash
"""
scalar StagedLedgerAuxHash

"""
Base58Check-encoded hash of a pending coinbase auxiliary hash
"""
scalar PendingCoinbaseAuxHash

"""
Base58Check-encoded hash of a pending coinbase hash
"""
scalar PendingCoinbaseHash

"""
A reference to how the block header refers to the body of the block as a hex-encoded string
"""
scalar BodyReference

"""
"""
type ConsensusState {
  """
  Length of the blockchain at this block
  """
  blockchainLength: Length! @deprecated(reason: "use blockHeight instead")

  """
  Height of the blockchain at this block
  """
  blockHeight: Length!

  """
  """
  epochCount: Length!

  """
  """
  minWindowDensity: Length!

  """
  """
  lastVrfOutput: String!

  """
  Total currency in circulation at this block
  """
  totalCurrency: Amount!

  """
  """
  stakingEpochData: StakingEpochData!

  """
  """
  nextEpochData: NextEpochData!

  """
  """
  hasAncestorInSameCheckpointWindow: Boolean!

  """
  Slot in which this block was created
  """
  slot: Slot!

  """
  Slot since genesis (across all hard-forks)
  """
  slotSinceGenesis: Globalslot!

  """
  Epoch in which this block was created
  """
  epoch: Epoch!

  """
  Whether or not this coinbase was "supercharged", ie. created by an account that has no locked tokens
  """
  superchargedCoinbase: Boolean!

  """
  The public key that is responsible for winning this block (including delegations)
  """
  blockStakeWinner: PublicKey!

  """
  The block producer public key that created this block
  """
  blockCreator: PublicKey!

  """
  """
  coinbaseReceiever: PublicKey!
}

"""
"""
type StakingEpochData {
  """
  """
  ledger: epochLedger!

  """
  """
  seed: EpochSeed!

  """
  """
  startCheckpoint: StateHash!

  """
  """
  lockCheckpoint: String!

  """
  """
  epochLength: Length!
}

"""
"""
type epochLedger {
  """
  """
  hash: LedgerHash!

  """
  """
  totalCurrency: Amount!
}

"""
Base58Check-encoded epoch seed
"""
scalar EpochSeed

"""
"""
type NextEpochData {
  """
  """
  ledger: epochLedger!

  """
  """
  seed: EpochSeed!

  """
  """
  startCheckpoint: StateHash!

  """
  """
  lockCheckpoint: String!

  """
  """
  epochLength: Length!
}

"""
slot
"""
scalar Slot

"""
epoch
"""
scalar Epoch

"""
"""
type protocolStateProof {
  """
  Base-64 encoded proof
  """
  base64: PrecomputedBlockProof

  """
  JSON-encoded proof
  """
  json: JSON
}

"""
Base-64 encoded proof
"""
scalar PrecomputedBlockProof

"""
Arbitrary JSON
"""
scalar JSON

"""
Different types of transactions in a block
"""
type Transactions {
  """
  List of user commands (payments and stake delegations) included in this block
  """
  userCommands: [UserCommand!]!

  """
  List of zkApp commands included in this block
  """
  zkappCommands: [ZkappCommandResult!]!

  """
  List of fee transfers included in this block
  """
  feeTransfer: [FeeTransfer!]!

  """
  Amount of MINA granted to the producer of this block
  """
  coinbase: Amount!

  """
  Account to which the coinbase for this block was granted
  """
  coinbaseReceiverAccount: Account
}

"""
Common interface for user commands
"""
interface UserCommand {
  """
  """
  id: TransactionId!

  """
  """
  hash: TransactionHash!

  """
  String describing the kind of user command
  """
  kind: UserCommandKind!

  """
  Sequence number of command for the fee-payer's account
  """
  nonce: Int!

  """
  Account that the command is sent from
  """
  source: Account!

  """
  Account that the command applies to
  """
  receiver: Account!

  """
  Account that pays the fees for the command
  """
  feePayer: Account!

  """
  The global slot number after which this transaction cannot be applied
  """
  validUntil: Globalslot!

  """
  Token used by the command
  """
  token: TokenId!

  """
  Amount that the source is sending to receiver - 0 for commands that are not associated with an amount
  """
  amount: Amount!

  """
  Token used to pay the fee
  """
  feeToken: TokenId!

  """
  Fee that the fee-payer is willing to pay for making the transaction
  """
  fee: Fee!

  """
  Short arbitrary message provided by the sender
  """
  memo: String!

  """
  If true, this represents a delegation of stake, otherwise it is a payment
  """
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  """
  Public key of the sender
  """
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  """
  Account of the sender
  """
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  """
  Public key of the receiver
  """
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  """
  Account of the receiver
  """
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  """
  null is no failure, reason for failure otherwise.
  """
  failureReason: TransactionStatusFailure
}

"""
Base64-encoded transaction
"""
scalar TransactionId

"""
Base58Check-encoded transaction hash
"""
scalar TransactionHash

"""
The kind of user command
"""
scalar UserCommandKind

"""
fee
"""
scalar Fee

"""
transaction status failure
"""
scalar TransactionStatusFailure

"""
"""
type ZkappCommandResult {
  """
  A Base64 string representing the zkApp command
  """
  id: TransactionId!

  """
  A cryptographic hash of the zkApp command
  """
  hash: TransactionHash!

  """
  zkApp command representing the transaction
  """
  zkappCommand: ZkappCommand!

  """
  The reason for the zkApp transaction failure; null means success or the status is unknown
  """
  failureReason: [ZkappCommandFailureReason]
}

"""
"""
type ZkappCommand {
  """
  """
  feePayer: ZkappFeePayer!

  """
  """
  accountUpdates: [ZkappAccountUpdate!]!

  """
  """
  memo: Memo!
}

"""
"""
type ZkappFeePayer {
  """
  """
  body: FeePayerBody!

  """
  """
  authorization: Signature!
}

"""
"""
type FeePayerBody {
  """
  """
  publicKey: PublicKey!

  """
  """
  fee: Fee!

  """
  """
  validUntil: UInt32

  """
  """
  nonce: UInt32!
}

scalar Signature

"""
An account update in a zkApp transaction
"""
type ZkappAccountUpdate {
  """
  """
  body: AccountUpdateBody!

  """
  """
  authorization: Control!
}

"""
"""
type AccountUpdateBody {
  """
  """
  publicKey: PublicKey!

  """
  """
  tokenId: TokenId!

  """
  """
  update: AccountUpdateModification!

  """
  """
  balanceChange: BalanceChange!

  """
  """
  incrementNonce: Boolean!

  """
  """
  events: [[Field!]!]!

  """
  """
  actions: [[Field!]!]!

  """
  """
  callData: Field!

  """
  """
  callDepth: Int!

  """
  """
  preconditions: Preconditions!

  """
  """
  useFullCommitment: Boolean!

  """
  """
  implicitAccountCreationFee: Boolean!

  """
  """
  mayUseToken: MayUseToken!

  """
  """
  authorizationKind: AuthorizationKindStructured!
}

"""
"""
type AccountUpdateModification {
  """
  """
  appState: [Field]!

  """
  """
  delegate: PublicKey

  """
  """
  verificationKey: VerificationKeyWithHash

  """
  """
  permissions: Permissions

  """
  """
  zkappUri: String

  """
  """
  tokenSymbol: String

  """
  """
  timing: Timing

  """
  """
  votingFor: StateHash
}

"""
String representing an Fp Field element
"""
scalar Field

"""
"""
type VerificationKeyWithHash {
  """
  """
  data: VerificationKey!

  """
  """
  hash: Field!
}

"""
"""
type Permissions {
  """
  """
  editState: AuthRequired!

  """
  """
  access: AuthRequired!

  """
  """
  send: AuthRequired!

  """
  """
  receive: AuthRequired!

  """
  """
  setDelegate: AuthRequired!

  """
  """
  setPermissions: AuthRequired!

  """
  """
  setVerificationKey: AuthRequired!

  """
  """
  setZkappUri: AuthRequired!

  """
  """
  editActionState: AuthRequired!

  """
  """
  setTokenSymbol: AuthRequired!

  """
  """
  incrementNonce: AuthRequired!

  """
  """
  setVotingFor: AuthRequired!

  """
  """
  setTiming: AuthRequired!
}

"""
Kind of authorization required
"""
scalar AuthRequired

"""
"""
type Timing {
  """
  """
  initialMinimumBalance: Balance!

  """
  """
  cliffTime: GlobalSlot!

  """
  """
  cliffAmount: CurrencyAmount!

  """
  """
  vestingPeriod: GlobalSlot!

  """
  """
  vestingIncrement: CurrencyAmount!
}

scalar GlobalSlot

scalar CurrencyAmount

"""
"""
type BalanceChange {
  """
  """
  magnitude: CurrencyAmount!

  """
  """
  sgn: Sign!
}

scalar Sign

"""
"""
type Preconditions {
  """
  """
  network: NetworkPrecondition!

  """
  """
  account: AccountPrecondition!

  """
  """
  validWhile: GlobalSlotInterval
}

"""
"""
type NetworkPrecondition {
  """
  """
  snarkedLedgerHash: Field

  """
  """
  blockchainLength: LengthInterval

  """
  """
  minWindowDensity: LengthInterval

  """
  """
  totalCurrency: CurrencyAmountInterval

  """
  """
  globalSlotSinceGenesis: GlobalSlotInterval

  """
  """
  stakingEpochData: EpochDataPrecondition!

  """
  """
  nextEpochData: EpochDataPrecondition!
}

"""
"""
type LengthInterval {
  """
  """
  lower: UInt32!

  """
  """
  upper: UInt32!
}

"""
"""
type CurrencyAmountInterval {
  """
  """
  lower: CurrencyAmount!

  """
  """
  upper: CurrencyAmount!
}

"""
"""
type GlobalSlotInterval {
  """
  """
  lower: UInt32!

  """
  """
  upper: UInt32!
}

"""
"""
type EpochDataPrecondition {
  """
  """
  ledger: EpochLedgerPrecondition!

  """
  """
  seed: Field

  """
  """
  startCheckpoint: Field

  """
  """
  lockCheckpoint: Field

  """
  """
  epochLength: LengthInterval
}

"""
"""
type EpochLedgerPrecondition {
  """
  """
  hash: Field

  """
  """
  totalCurrency: CurrencyAmountInterval
}

"""
"""
type AccountPrecondition {
  """
  """
  balance: BalanceInterval

  """
  """
  nonce: NonceInterval

  """
  """
  receiptChainHash: Field

  """
  """
  delegate: PublicKey

  """
  """
  state: [Field]!

  """
  """
  actionState: Field

  """
  """
  provedState: Boolean

  """
  """
  isNew: Boolean
}

"""
"""
type BalanceInterval {
  """
  """
  lower: Balance!

  """
  """
  upper: Balance!
}

"""
"""
type NonceInterval {
  """
  """
  lower: UInt32!

  """
  """
  upper: UInt32!
}

"""
"""
type MayUseToken {
  """
  """
  parentsOwnToken: Boolean!

  """
  """
  inheritFromParent: Boolean!
}

"""
"""
type AuthorizationKindStructured {
  """
  """
  isSigned: Boolean!

  """
  """
  isProved: Boolean!

  """
  """
  verificationKeyHash: Field!
}

"""
"""
type Control {
  """
  """
  proof: ZkappProof

  """
  """
  signature: Signature
}

scalar ZkappProof

scalar Memo

"""
"""
type ZkappCommandFailureReason {
  """
  List index of the account update that failed
  """
  index: Index

  """
  Failure reason for the account update or any nested zkapp command
  """
  failures: [TransactionStatusFailure!]!
}

"""
ocaml integer as a string
"""
scalar Index

"""
"""
type FeeTransfer {
  """
  Public key of fee transfer recipient
  """
  recipient: PublicKey!

  """
  Amount that the recipient is paid in this fee transfer
  """
  fee: Fee!

  """
  Fee_transfer|Fee_transfer_via_coinbase Snark worker fees deducted from the
  coinbase amount are of type 'Fee_transfer_via_coinbase', rest are deducted
  from transaction fees
  """
  type: FeeTransferType!
}

"""
fee transfer type
"""
scalar FeeTransferType

"""
Completed snark works
"""
type CompletedWork {
  """
  Public key of the prover
  """
  prover: PublicKey!

  """
  Amount the prover is paid for the snark work
  """
  fee: Fee!

  """
  Unique identifier for the snark work purchased
  """
  workIds: [Int!]!
}

"""
Status of a transaction
"""
enum TransactionStatus {
  """
  A transaction that is on the longest chain
  """
  INCLUDED

  """
  A transaction either in the transition frontier or in transaction pool but is not on the longest chain
  """
  PENDING

  """
  The transaction has either been snarked, reached finality through consensus or has been dropped
  """
  UNKNOWN
}

"""
"""
type TrustStatusPayload {
  """
  IP address
  """
  ipAddr: InetAddr!

  """
  libp2p Peer ID
  """
  peerId: String!

  """
  Trust score
  """
  trust: Float!

  """
  Banned status
  """
  bannedStatus: Time
}

"""
network address
"""
scalar InetAddr

"""
Snark work bundles that are not available in the pool yet
"""
type PendingSnarkWork {
  """
  Work bundle with one or two snark work
  """
  workBundle: [WorkDescription!]!
}

"""
Transition from a source ledger to a target ledger with some fee excess and increase in supply
"""
type WorkDescription {
  """
  Base58Check-encoded hash of the source first-pass ledger
  """
  sourceFirstPassLedgerHash: LedgerHash!

  """
  Base58Check-encoded hash of the target first-pass ledger
  """
  targetFirstPassLedgerHash: LedgerHash!

  """
  Base58Check-encoded hash of the source second-pass ledger
  """
  sourceSecondPassLedgerHash: LedgerHash!

  """
  Base58Check-encoded hash of the target second-pass ledger
  """
  targetSecondPassLedgerHash: LedgerHash!

  """
  Total transaction fee that is not accounted for in the transition from source ledger to target ledger
  """
  feeExcess: SignedFee!

  """
  Increase in total supply
  """
  supplyIncrease: Amount! @deprecated(reason: "Use supplyChange")

  """
  Increase/Decrease in total supply
  """
  supplyChange: SignedFee!

  """
  Unique identifier for a snark work
  """
  workId: Int!
}

"""
Signed fee
"""
type SignedFee {
  """
  +/-
  """
  sign: sign!

  """
  Fee
  """
  feeMagnitude: Amount!
}

"""
"""
enum sign {
  """
  """
  PLUS

  """
  """
  MINUS
}

"""
"""
type GenesisConstants {
  """
  The fee charged to create a new account
  """
  accountCreationFee: Fee!

  """
  The amount received as a coinbase reward for producing a block
  """
  coinbase: Amount!
}

"""
A cryptographic signature -- you must provide either field+scalar or rawSignature
"""
input SignatureInput {
  """
  Raw encoded signature
  """
  rawSignature: String

  """
  Scalar component of signature
  """
  scalar: String

  """
  Field component of signature
  """
  field: String
}

"""
"""
input SendPaymentInput {
  """
  Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  """
  nonce: UInt32

  """
  Short arbitrary message provided by the sender
  """
  memo: String

  """
  The global slot since genesis after which this transaction cannot be applied
  """
  validUntil: UInt32

  """
  Fee amount in order to send payment
  """
  fee: UInt64!

  """
  Amount of MINA to send to receiver
  """
  amount: UInt64!

  """
  Public key of recipient of payment
  """
  to: PublicKey!

  """
  Public key of sender of payment
  """
  from: PublicKey!
}

"""
String or Integer representation of a uint64 number. If the input is a string, it must represent the number in base 10
"""
scalar UInt64

"""
The amount of stake delegated, used to determine the threshold for a vrf evaluation producing a block
"""
input VrfThresholdInput {
  """
  The total amount of stake across all accounts in the epoch's staking ledger.
  """
  totalStake: UInt64!

  """
  The amount of stake delegated to the vrf evaluator by the delegating account.
  This should match the amount in the epoch's staking ledger, which may be
  different to the amount in the current ledger.
  """
  delegatedStake: UInt64!
}

"""
The inputs to a vrf evaluation
"""
input VrfMessageInput {
  """
  Position in the ledger of the delegator's account
  """
  delegatorIndex: Int!

  """
  Formatted with base58check
  """
  epochSeed: String!

  """
  """
  globalSlot: UInt32!
}

"""
A witness to a vrf evaluation, which may be externally verified
"""
type VrfEvaluation {
  """
  """
  message: VrfMessage!

  """
  """
  publicKey: PublicKey!

  """
  """
  c: VrfScalar!

  """
  """
  s: VrfScalar!

  """
  A group element represented as 2 field elements
  """
  scaledMessageHash: [String!]!

  """
  """
  vrfThreshold: VrfThreshold

  """
  The vrf output derived from the evaluation witness. If null, the vrf witness was invalid.
  """
  vrfOutput: VrfOutputTruncated

  """
  The vrf output derived from the evaluation witness, as a fraction. This
  represents a won slot if vrfOutputFractional <= (1 - (1 /
  4)^(delegated_balance / total_stake)). If null, the vrf witness was invalid.
  """
  vrfOutputFractional: Float

  """
  Whether the threshold to produce a block was met, if specified
  """
  thresholdMet(
    """
    Override for delegation threshold
    """
    input: VrfThresholdInput
  ): Boolean
}

"""
The inputs to a vrf evaluation
"""
type VrfMessage {
  """
  """
  globalSlot: Globalslot!

  """
  """
  epochSeed: EpochSeed!

  """
  Position in the ledger of the delegator's account
  """
  delegatorIndex: Int!
}

"""
consensus vrf scalar
"""
scalar VrfScalar

"""
The amount of stake delegated, used to determine the threshold for a vrf evaluation winning a slot
"""
type VrfThreshold {
  """
  The amount of stake delegated to the vrf evaluator by the delegating account.
  This should match the amount in the epoch's staking ledger, which may be
  different to the amount in the current ledger.
  """
  delegatedStake: Balance!

  """
  The total amount of stake across all accounts in the epoch's staking ledger.
  """
  totalStake: Amount!
}

"""
truncated vrf output
"""
scalar VrfOutputTruncated

"""
The witness to a vrf evaluation
"""
input VrfEvaluationInput {
  """
  """
  vrfThreshold: VrfThresholdInput

  """
  """
  scaledMessageHash: [String!]!

  """
  """
  s: String!

  """
  """
  c: String!

  """
  """
  publicKey: PublicKey!

  """
  """
  message: VrfMessageInput!
}

"""
"""
type mutation {
  """
  Add a wallet - this will create a new keypair and store it in the daemon
  """
  addWallet(input: AddAccountInput!): AddAccountPayload!
    @deprecated(reason: "use createAccount instead")

  """
  Allow transactions to be sent from the unlocked account
  """
  unlockWallet(input: UnlockInput!): UnlockPayload!
    @deprecated(reason: "use unlockAccount instead")

  """
  Lock an unlocked account to prevent transaction being sent from it
  """
  lockWallet(input: LockInput!): LockPayload!
    @deprecated(reason: "use lockAccount instead")

  """
  Delete the private key for an account that you track
  """
  deleteWallet(input: DeleteAccountInput!): DeleteAccountPayload!
    @deprecated(reason: "use deleteAccount instead")

  """
  Reload tracked account information from disk
  """
  reloadWallets: ReloadAccountsPayload!
    @deprecated(reason: "use reloadAccounts instead")

  """
  Send a payment
  """
  sendPayment(
    """
    If a signature is provided, this transaction is considered signed and will
    be broadcasted to the network without requiring a private key
    """
    signature: SignatureInput

    """
    """
    input: SendPaymentInput!
  ): SendPaymentPayload!

  """
  Send a series of test payments
  """
  sendTestPayments(
    """
    Delay with which a transaction shall be repeated
    """
    repeat_delay_ms: UInt32!

    """
    How many times shall transaction be repeated
    """
    repeat_count: UInt32!

    """
    The fee of each payment
    """
    fee: UInt64!

    """
    The amount of each payment
    """
    amount: UInt64!

    """
    The receiver of the payments
    """
    receiver: PublicKey!

    """
    The private keys from which to sign the payments
    """
    senders: [PrivateKey!]!
  ): Int!

  """
  Change your delegate by sending a transaction
  """
  sendDelegation(
    """
    If a signature is provided, this transaction is considered signed and will
    be broadcasted to the network without requiring a private key
    """
    signature: SignatureInput

    """
    """
    input: SendDelegationInput!
  ): SendDelegationPayload!

  """
  Send a zkApp transaction
  """
  sendZkapp(input: SendZkappInput!): SendZkappPayload!

  """
  Mock a zkApp transaction, no effect on blockchain
  """
  mockZkapp(input: SendZkappInput!): SendZkappPayload!

  """
  Send a zkApp (for internal testing purposes)
  """
  internalSendZkapp(zkappCommand: SendTestZkappInput!): SendZkappPayload!

  """
  Send a transaction in Rosetta format
  """
  sendRosettaTransaction(
    input: RosettaTransaction!
  ): SendRosettaTransactionPayload!
}

"""
"""
input AddAccountInput {
  """
  Password used to encrypt the new account
  """
  password: String!
}

"""
"""
type AddAccountPayload {
  """
  Public key of the created account
  """
  publicKey: PublicKey! @deprecated(reason: "use account field instead")

  """
  Details of created account
  """
  account: Account!
}

"""
"""
input UnlockInput {
  """
  Public key specifying which account to unlock
  """
  publicKey: PublicKey!

  """
  Password for the account to be unlocked
  """
  password: String!
}

"""
"""
type UnlockPayload {
  """
  Public key of the unlocked account
  """
  publicKey: PublicKey! @deprecated(reason: "use account field instead")

  """
  Details of unlocked account
  """
  account: Account!
}

"""
"""
input LockInput {
  """
  Public key specifying which account to lock
  """
  publicKey: PublicKey!
}

"""
"""
type LockPayload {
  """
  Public key of the locked account
  """
  publicKey: PublicKey!

  """
  Details of locked account
  """
  account: Account!
}

"""
"""
input DeleteAccountInput {
  """
  Public key of account to be deleted
  """
  publicKey: PublicKey!
}

"""
"""
type DeleteAccountPayload {
  """
  Public key of the deleted account
  """
  publicKey: PublicKey!
}

"""
"""
type ReloadAccountsPayload {
  """
  True when the reload was successful
  """
  success: Boolean!
}

"""
"""
type SendPaymentPayload {
  """
  Payment that was sent
  """
  payment: UserCommand!
}

"""
Base58Check-encoded private key
"""
scalar PrivateKey

"""
"""
input SendDelegationInput {
  """
  Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  """
  nonce: UInt32

  """
  Short arbitrary message provided by the sender
  """
  memo: String

  """
  The global slot since genesis after which this transaction cannot be applied
  """
  validUntil: UInt32

  """
  Fee amount in order to send a stake delegation
  """
  fee: UInt64!

  """
  Public key of the account being delegated to
  """
  to: PublicKey!

  """
  Public key of sender of a stake delegation
  """
  from: PublicKey!
}

"""
"""
type SendDelegationPayload {
  """
  Delegation change that was sent
  """
  delegation: UserCommand!
}

"""
"""
input SendZkappInput {
  """
  zkApp command structure representing the transaction
  """
  zkappCommand: ZkappCommandInput!
}

"""
"""
input ZkappCommandInput {
  """
  """
  feePayer: ZkappFeePayerInput!

  """
  """
  accountUpdates: [ZkappAccountUpdateInput!]!

  """
  """
  memo: Memo!
}

"""
"""
input ZkappFeePayerInput {
  """
  """
  body: FeePayerBodyInput!

  """
  """
  authorization: Signature!
}

"""
"""
input FeePayerBodyInput {
  """
  """
  publicKey: PublicKey!

  """
  """
  fee: Fee!

  """
  """
  validUntil: UInt32

  """
  """
  nonce: UInt32!
}

"""
An account update in a zkApp transaction
"""
input ZkappAccountUpdateInput {
  """
  """
  body: AccountUpdateBodyInput!

  """
  """
  authorization: ControlInput!
}

"""
"""
input AccountUpdateBodyInput {
  """
  """
  publicKey: PublicKey!

  """
  """
  tokenId: TokenId!

  """
  """
  update: AccountUpdateModificationInput!

  """
  """
  balanceChange: BalanceChangeInput!

  """
  """
  incrementNonce: Boolean!

  """
  """
  events: [[Field!]!]!

  """
  """
  actions: [[Field!]!]!

  """
  """
  callData: Field!

  """
  """
  callDepth: Int!

  """
  """
  preconditions: PreconditionsInput!

  """
  """
  useFullCommitment: Boolean!

  """
  """
  implicitAccountCreationFee: Boolean!

  """
  """
  mayUseToken: MayUseTokenInput!

  """
  """
  authorizationKind: AuthorizationKindStructuredInput!
}

"""
"""
input AccountUpdateModificationInput {
  """
  """
  appState: [Field]!

  """
  """
  delegate: PublicKey

  """
  """
  verificationKey: VerificationKeyWithHashInput

  """
  """
  permissions: PermissionsInput

  """
  """
  zkappUri: String

  """
  """
  tokenSymbol: String

  """
  """
  timing: TimingInput

  """
  """
  votingFor: StateHash
}

"""
"""
input VerificationKeyWithHashInput {
  """
  """
  data: VerificationKey!

  """
  """
  hash: Field!
}

"""
"""
input PermissionsInput {
  """
  """
  editState: AuthRequired!

  """
  """
  access: AuthRequired!

  """
  """
  send: AuthRequired!

  """
  """
  receive: AuthRequired!

  """
  """
  setDelegate: AuthRequired!

  """
  """
  setPermissions: AuthRequired!

  """
  """
  setVerificationKey: AuthRequired!

  """
  """
  setZkappUri: AuthRequired!

  """
  """
  editActionState: AuthRequired!

  """
  """
  setTokenSymbol: AuthRequired!

  """
  """
  incrementNonce: AuthRequired!

  """
  """
  setVotingFor: AuthRequired!

  """
  """
  setTiming: AuthRequired!
}

"""
"""
input TimingInput {
  """
  """
  initialMinimumBalance: Balance!

  """
  """
  cliffTime: GlobalSlot!

  """
  """
  cliffAmount: CurrencyAmount!

  """
  """
  vestingPeriod: GlobalSlot!

  """
  """
  vestingIncrement: CurrencyAmount!
}

"""
"""
input BalanceChangeInput {
  """
  """
  magnitude: CurrencyAmount!

  """
  """
  sgn: Sign!
}

"""
"""
input PreconditionsInput {
  """
  """
  network: NetworkPreconditionInput!

  """
  """
  account: AccountPreconditionInput!

  """
  """
  validWhile: GlobalSlotIntervalInput
}

"""
"""
input NetworkPreconditionInput {
  """
  """
  snarkedLedgerHash: Field

  """
  """
  blockchainLength: LengthIntervalInput

  """
  """
  minWindowDensity: LengthIntervalInput

  """
  """
  totalCurrency: CurrencyAmountIntervalInput

  """
  """
  globalSlotSinceGenesis: GlobalSlotIntervalInput

  """
  """
  stakingEpochData: EpochDataPreconditionInput!

  """
  """
  nextEpochData: EpochDataPreconditionInput!
}

"""
"""
input LengthIntervalInput {
  """
  """
  lower: UInt32!

  """
  """
  upper: UInt32!
}

"""
"""
input CurrencyAmountIntervalInput {
  """
  """
  lower: CurrencyAmount!

  """
  """
  upper: CurrencyAmount!
}

"""
"""
input GlobalSlotIntervalInput {
  """
  """
  lower: UInt32!

  """
  """
  upper: UInt32!
}

"""
"""
input EpochDataPreconditionInput {
  """
  """
  ledger: EpochLedgerPreconditionInput!

  """
  """
  seed: Field

  """
  """
  startCheckpoint: Field

  """
  """
  lockCheckpoint: Field

  """
  """
  epochLength: LengthIntervalInput
}

"""
"""
input EpochLedgerPreconditionInput {
  """
  """
  hash: Field

  """
  """
  totalCurrency: CurrencyAmountIntervalInput
}

"""
"""
input AccountPreconditionInput {
  """
  """
  balance: BalanceIntervalInput

  """
  """
  nonce: NonceIntervalInput

  """
  """
  receiptChainHash: Field

  """
  """
  delegate: PublicKey

  """
  """
  state: [Field]!

  """
  """
  actionState: Field

  """
  """
  provedState: Boolean

  """
  """
  isNew: Boolean
}

"""
"""
input BalanceIntervalInput {
  """
  """
  lower: Balance!

  """
  """
  upper: Balance!
}

"""
"""
input NonceIntervalInput {
  """
  """
  lower: UInt32!

  """
  """
  upper: UInt32!
}

"""
"""
input MayUseTokenInput {
  """
  """
  parentsOwnToken: Boolean!

  """
  """
  inheritFromParent: Boolean!
}

"""
"""
input AuthorizationKindStructuredInput {
  """
  """
  isSigned: Boolean!

  """
  """
  isProved: Boolean!

  """
  """
  verificationKeyHash: Field!
}

"""
"""
input ControlInput {
  """
  """
  proof: ZkappProof

  """
  """
  signature: Signature
}

"""
"""
type SendZkappPayload {
  """
  zkApp transaction that was sent
  """
  zkapp: ZkappCommandResult!
}

"""
zkApp command for a test zkApp
"""
scalar SendTestZkappInput

"""
A transaction encoded in the Rosetta format
"""
scalar RosettaTransaction

"""
"""
type SendRosettaTransactionPayload {
  """
  Command that was sent
  """
  userCommand: UserCommand!
}

"""
"""
type subscription {
  """
  Event that triggers when the network sync status changes
  """
  newSyncUpdate: SyncStatus!

  """
  Event that triggers when a new block is created that either contains a
  transaction with the specified public key, or was produced by it. If no public
  key is provided, then the event will trigger for every new block received
  """
  newBlock(
    """
    Public key that is included in the block
    """
    publicKey: PublicKey
  ): Block!

  """
  Event that triggers when the best tip changes in a way that is not a trivial extension of the existing one
  """
  chainReorganization: ChainReorganizationStatus!
}

"""
Status for whenever the blockchain is reorganized
"""
enum ChainReorganizationStatus {
  """
  """
  CHANGED
}

"""
"""
type SetConnectionGatingConfigPayload {
  """
  Peers we will always allow connections from
  """
  trustedPeers: [NetworkPeerPayload!]!

  """
  Peers we will never allow connections from (unless they are also trusted!)
  """
  bannedPeers: [NetworkPeerPayload!]!

  """
  If true, no connections will be allowed unless they are from a trusted peer
  """
  isolate: Boolean!
}

"""
"""
type NetworkPeerPayload {
  """
  base58-encoded peer ID
  """
  peerId: String!

  """
  IP address of the remote host
  """
  host: InetAddr!

  """
  """
  libp2pPort: Int!
}

"""
"""
type SnarkWorker {
  """
  Public key of current snark worker
  """
  key: PublicKey! @deprecated(reason: "use account field instead")

  """
  Account of the current snark worker
  """
  account: Account!

  """
  Fee that snark worker is charging to generate a snark proof
  """
  fee: Fee!
}

"""
"""
input CreateHDAccountInput {
  """
  Index of the account in hardware wallet
  """
  index: UInt32!
}

"""
"""
type ImportAccountPayload {
  """
  The public key of the imported account
  """
  publicKey: PublicKey!

  """
  True if the account had already been imported
  """
  alreadyImported: Boolean!

  """
  """
  success: Boolean!
}

"""
"""
type ExportLogsPayload {
  """
  Tar archive containing logs
  """
  exportLogs: TarFile!
}

"""
"""
type TarFile {
  """
  """
  tarfile: String!
}

"""
"""
input SetCoinbaseReceiverInput {
  """
  Public key of the account to receive coinbases. Block production keys will
  receive the coinbases if omitted. Warning: If the key is from a zkApp account,
  the account's receive permission must be None.
  """
  publicKey: PublicKey
}

"""
"""
type SetCoinbaseReceiverPayload {
  """
  Returns the public key that was receiving coinbases previously, or none if it was the block producer
  """
  lastCoinbaseReceiver: PublicKey

  """
  Returns the public key that will receive coinbase, or none if it will be the block producer
  """
  currentCoinbaseReceiver: PublicKey
}

"""
"""
input SetSnarkWorkerInput {
  """
  Public key you wish to start snark-working on; null to stop doing any snark
  work. Warning: If the key is from a zkApp account, the account's receive
  permission must be None.
  """
  publicKey: PublicKey
}

"""
"""
type SetSnarkWorkerPayload {
  """
  Returns the last public key that was designated for snark work
  """
  lastSnarkWorker: PublicKey
}

"""
"""
input SetSnarkWorkFee {
  """
  Fee to get rewarded for producing snark work
  """
  fee: UInt64!
}

"""
"""
type SetSnarkWorkFeePayload {
  """
  Returns the last fee set to do snark work
  """
  lastFee: Fee!
}

"""
"""
input SetConnectionGatingConfigInput {
  """
  If true, no connections will be allowed unless they are from a trusted peer
  """
  isolate: Boolean!

  """
  Peers we will never allow connections from (unless they are also trusted!)
  """
  bannedPeers: [NetworkPeer!]!

  """
  Peers we will always allow connections from
  """
  trustedPeers: [NetworkPeer!]!
}

"""
Network identifiers for another protocol participant
"""
input NetworkPeer {
  """
  """
  libp2pPort: Int!

  """
  IP address of the remote host
  """
  host: String!

  """
  base58-encoded peer ID
  """
  peerId: String!
}

"""
Block encoded in precomputed block format
"""
scalar PrecomputedBlock

"""
"""
type Applied {
  """
  """
  applied: Boolean!
}

"""
Block encoded in extensional block format
"""
scalar ExtensionalBlock

"""
"""
type UserCommandDelegation implements UserCommand {
  """
  """
  delegator: Account!

  """
  """
  delegatee: Account!

  """
  """
  id: TransactionId!

  """
  """
  hash: TransactionHash!

  """
  String describing the kind of user command
  """
  kind: UserCommandKind!

  """
  Sequence number of command for the fee-payer's account
  """
  nonce: Int!

  """
  Account that the command is sent from
  """
  source: Account!

  """
  Account that the command applies to
  """
  receiver: Account!

  """
  Account that pays the fees for the command
  """
  feePayer: Account!

  """
  The global slot number after which this transaction cannot be applied
  """
  validUntil: Globalslot!

  """
  Token used for the transaction
  """
  token: TokenId!

  """
  Amount that the source is sending to receiver; 0 for commands without an associated amount
  """
  amount: Amount!

  """
  Token used to pay the fee
  """
  feeToken: TokenId!

  """
  Fee that the fee-payer is willing to pay for making the transaction
  """
  fee: Fee!

  """
  A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  """
  memo: String!

  """
  If true, this command represents a delegation of stake
  """
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  """
  Public key of the sender
  """
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  """
  Account of the sender
  """
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  """
  Public key of the receiver
  """
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  """
  Account of the receiver
  """
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  """
  null is no failure or status unknown, reason for failure otherwise.
  """
  failureReason: TransactionStatusFailure
}

"""
"""
type UserCommandPayment implements UserCommand {
  """
  """
  id: TransactionId!

  """
  """
  hash: TransactionHash!

  """
  String describing the kind of user command
  """
  kind: UserCommandKind!

  """
  Sequence number of command for the fee-payer's account
  """
  nonce: Int!

  """
  Account that the command is sent from
  """
  source: Account!

  """
  Account that the command applies to
  """
  receiver: Account!

  """
  Account that pays the fees for the command
  """
  feePayer: Account!

  """
  The global slot number after which this transaction cannot be applied
  """
  validUntil: Globalslot!

  """
  Token used for the transaction
  """
  token: TokenId!

  """
  Amount that the source is sending to receiver; 0 for commands without an associated amount
  """
  amount: Amount!

  """
  Token used to pay the fee
  """
  feeToken: TokenId!

  """
  Fee that the fee-payer is willing to pay for making the transaction
  """
  fee: Fee!

  """
  A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  """
  memo: String!

  """
  If true, this command represents a delegation of stake
  """
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  """
  Public key of the sender
  """
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  """
  Account of the sender
  """
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  """
  Public key of the receiver
  """
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  """
  Account of the receiver
  """
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  """
  null is no failure or status unknown, reason for failure otherwise.
  """
  failureReason: TransactionStatusFailure
}
